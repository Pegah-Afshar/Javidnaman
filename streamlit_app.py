import streamlit as st
import pandas as pd
import gspread
from google.oauth2.service_account import Credentials
from streamlit_searchbox import st_searchbox
import time

# ==========================================
# 1. CONFIGURATION
# ==========================================
# No mandatory fields
REQUIRED_FIELDS = [] 
NUMERIC_FIELDS = ["Ø³Ù†", "Ø³Ø§Ù„ ØªÙˆÙ„Ø¯"]

st.set_page_config(page_title="Ù…Ø¯ÛŒØ±ÛŒØª Ø¬Ø§ÙˆÛŒØ¯Ù†Ø§Ù…Ø§Ù†", layout="wide", page_icon="ğŸ“‹")

# CSS: RTL, Cards, and hiding the search label
st.markdown("""<style>
    [data-testid="stAppViewContainer"] { direction: rtl; text-align: right; font-family: 'Tahoma', sans-serif; }
    label, input, textarea, .stSelectbox, .stMarkdown, .stToast { direction: rtl !important; text-align: right !important; }
    .stButton button { width: 100%; background-color: #1a73e8; color: white; border-radius: 8px; font-weight: bold; transition: 0.3s; }
    .stButton button:hover { background-color: #1557b0; }
    .st-emotion-cache-16idsys p { display: none; } /* Hide searchbox label to keep UI clean */
    [data-testid="stForm"] { border: 1px solid #ddd; padding: 20px; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
</style>""", unsafe_allow_html=True)

# ==========================================
# 2. BACKEND CONNECTION
# ==========================================
@st.cache_resource
def get_connection():
    scope = ["https://www.googleapis.com/auth/spreadsheets"]
    creds = Credentials.from_service_account_info(st.secrets["gspread_creds"], scopes=scope)
    client = gspread.authorize(creds)
    return client

@st.cache_data(ttl=5) 
def get_data():
    client = get_connection()
    sheet = client.open_by_url(st.secrets["public_gsheets_url"]).get_worksheet(0)
    # Get all records as strings to prevent errors
    return pd.DataFrame(sheet.get_all_records(expected_headers=[]))

# ==========================================
# 3. LOGIC & STATE
# ==========================================
if 'active_name' not in st.session_state:
    st.session_state.active_name = None

try:
    df = get_data()
    all_headers = df.columns.tolist()
    form_headers = [h for h in all_headers if h and h != 'Ø§Ø³Ù…']
    existing_names = [x for x in df['Ø§Ø³Ù…'].dropna().unique().tolist() if x]
except Exception as e:
    st.error("Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø§ÛŒÙ†ØªØ±Ù†Øª.")
    st.stop()

def search_names(search_term: str):
    # 1. If empty, show full list
    if not search_term:
        return existing_names
    
    # 2. Find matches
    matches = [n for n in existing_names if search_term in n]
    
    # 3. CRITICAL: Add the user's typed name to the VERY TOP
    # This ensures that if they type "New Name" and hit Enter, it selects this option.
    if search_term not in matches:
        matches.insert(0, search_term)
        
    return matches

st.title("ğŸ“‹ Ø³Ø§Ù…Ø§Ù†Ù‡ Ù…Ø¯ÛŒØ±ÛŒØª Ù‡ÙˆØ´Ù…Ù†Ø¯")

# ==========================================
# SCREEN 1: SEARCH (DROPDOWN MODE)
# ==========================================
if st.session_state.active_name is None:
    st.info("ğŸ‘‡ Ù†Ø§Ù… Ø±Ø§ Ø¬Ø³ØªØ¬Ùˆ Ú©Ù†ÛŒØ¯ (Ø§Ù†ØªØ®Ø§Ø¨ Ø§Ø² Ù„ÛŒØ³Øª) ÛŒØ§ Ù†Ø§Ù… Ø¬Ø¯ÛŒØ¯ Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯ Ùˆ **Ø§ÛŒÙ†ØªØ± Ø¨Ø²Ù†ÛŒØ¯**")
    
    # We use st_searchbox to get the Dropdown functionality back
    selected_value = st_searchbox(
        search_names,
        key="search_box_main",
        placeholder="Ù†Ø§Ù… Ø±Ø§ ØªØ§ÛŒÙ¾ Ú©Ù†ÛŒØ¯..."
    )

    if selected_value:
        st.session_state.active_name = selected_value
        st.rerun()

# ==========================================
# SCREEN 2: ENTRY FORM
# ==========================================
else:
    locked_name = st.session_state.active_name
    is_edit_mode = locked_name in existing_names
    
    # Header
    c_info, c_btn = st.columns([6, 1])
    with c_info:
        if is_edit_mode:
            st.success(f"âœï¸ ÙˆÛŒØ±Ø§ÛŒØ´: **{locked_name}**")
        else:
            st.warning(f"ğŸ†• Ø«Ø¨Øª Ø¬Ø¯ÛŒØ¯: **{locked_name}**")
    
    with c_btn:
        if st.button("âŒ Ø§Ù†ØµØ±Ø§Ù"):
            # Cleanup Inputs
            for header in form_headers:
                if f"input_{header}" in st.session_state: del st.session_state[f"input_{header}"]
            # Cleanup Search Memory
            if "search_box_main" in st.session_state: del st.session_state["search_box_main"]
            
            st.session_state.active_name = None
            st.rerun()

    # Data Prep
    current_data = df[df['Ø§Ø³Ù…'] == locked_name].iloc[0].to_dict() if is_edit_mode else {}

    # Form
    with st.form("entry_form", border=True):
        st.markdown(f"### ğŸ“„ Ù…Ø´Ø®ØµØ§Øª: {locked_name}")
        st.markdown("---")
        
        cols = st.columns(3) 
        user_inputs = {}

        for i, header in enumerate(form_headers):
            with cols[i % 3]:
                val = current_data.get(header, "")
                user_inputs[header] = st.text_input(header, value=str(val), key=f"input_{header}")

        st.markdown("---")
        
        c_sub, c_nul = st.columns([2, 5])
        with c_sub:
            submitted = st.form_submit_button("ğŸ’¾ Ø«Ø¨Øª Ù†Ù‡Ø§ÛŒÛŒ")

        if submitted:
            # Simple numeric check only
            validation_errors = []
            for field in NUMERIC_FIELDS:
                if field in user_inputs and user_inputs[field].strip():
                    if not user_inputs[field].strip().isdigit():
                        validation_errors.append(f"â›” ÙÛŒÙ„Ø¯ **{field}** Ø¨Ø§ÛŒØ¯ Ø¹Ø¯Ø¯ Ø¨Ø§Ø´Ø¯.")
            
            if validation_errors:
                for err in validation_errors: st.error(err)
            else:
                try:
                    # Check Changes
                    changes_detected = True
                    if is_edit_mode:
                        changes_detected = False
                        for header in form_headers:
                            if str(current_data.get(header, "")).strip() != user_inputs.get(header, "").strip():
                                changes_detected = True
                                break
                    
                    if not changes_detected:
                        st.info("â„¹ï¸ ØªØºÛŒÛŒØ±ÛŒ Ø¯Ø§Ø¯Ù‡ Ù†Ø´Ø¯.")
                        time.sleep(1.5)
                        # Reset
                        if "search_box_main" in st.session_state: del st.session_state["search_box_main"]
                        st.session_state.active_name = None
                        st.rerun()
                    else:
                        # Save
                        with st.status("ğŸ“¡ Ø¯Ø± Ø­Ø§Ù„ Ø°Ø®ÛŒØ±Ù‡...", expanded=True) as status:
                            client = get_connection()
                            sheet = client.open_by_url(st.secrets["public_gsheets_url"]).get_worksheet(0)
                            
                            final_row = []
                            for header in all_headers:
                                if header == 'Ø§Ø³Ù…':
                                    final_row.append(locked_name)
                                else:
                                    final_row.append(str(user_inputs.get(header, "")))
                            
                            if is_edit_mode:
                                cell = sheet.find(locked_name)
                                sheet.update(range_name=f"A{cell.row}", values=[final_row])
                            else:
                                sheet.append_row(final_row)
                            
                            get_data.clear() 
                            status.update(label="âœ… Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯!", state="complete", expanded=False)
                        
                        st.toast("Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯", icon='ğŸ‰')
                        time.sleep(1)
                        
                        # Full Reset
                        for header in form_headers:
                            if f"input_{header}" in st.session_state: del st.session_state[f"input_{header}"]
                        if "search_box_main" in st.session_state: del st.session_state["search_box_main"]
                        
                        st.session_state.active_name = None
                        st.rerun()
                        
                except Exception as e:
                    st.error(f"âŒ Ø®Ø·Ø§: {e}")
